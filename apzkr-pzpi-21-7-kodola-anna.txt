Міністерство освіти і науки України
Харківський національний університет радіоелектроніки


Факультет комп’ютерних наук

Кафедра програмної інженерії

КУРСОВА РОБОТА
ПОЯСНЮВАЛЬНА ЗАПИСКА
з навчальної дисципліни «Архітектура програмного забезпечення»
Тема роботи: Програмна система для керування та організації роботи мережі приватних клінік


Студентка гр. ПЗПІ-21-7	_____________ Кодола А.Т.
(підпис)
Керівник роботи	_____________ ст. викл. Сокорчук І.П.
(підпис)
	Роботу захищено «__»________ 2024 р. з оцінкою ________________________
	
Комісія:	_____________ доц. Лещинський В.О.
      (підпис)
	_____________ доц. Лещинська І.О.
         (підпис)
	_____________ ст. викл. Сокорчук І.П.
         (підпис)


Харків
2024 р.
Харківський національний університет радіоелектроніки 

Факультет комп’ютерних наук      Кафедра програмної інженерії	
Спеціальність 121 – Інженерія програмного забезпечення		
Курс                     3                     Семестр 	                  6 		
Навчальна дисципліна Архітектура програмного забезпечення	

ЗАВДАННЯ 
НА КУРСОВУ РОБОТИ СТУДЕНТОВІ  

                                              Кодолі Анні Тимофіївні				
1. Тема проєкту: «Програмна система для керування та організації роботи мережі приватних клінік» 
2. Термін узгодження завдання курсової роботи: «  25  » березня	 2024 р.
3. Термін здачі студентом закінченої роботи: «       »                        2024 р.  
4. Вихідні дані до проекту: В програмній системі передбачити: додавання, редагування, видалення клінік, користувачів, медичних записів, записів на прийом до лікарів, розкладів лікарів, рахунків. Використовувати OC Windows 11, СКБД MongoDB, середовище розробки WebStorm				
5. Зміст пояснювальної записки (перелік питань, що належить розробити):
вступ, аналіз предметної області, постановка задачі, проектування  програмного проекту, структура бази даних, кодування програмного  проекту, опис розробленої програмної системи, висновки, перелік посилань,  додатки											
6. Перелік графічного матеріалу (з точними зазначенням обов’язкових креслень):схема бази даних, діаграма варіантів використання, діаграма розгортання, інтерфейс головної сторінки					

 
КАЛЕНДАРНИЙ ПЛАН


№	Назва етапів курсової роботи	Термін виконання етапів роботи	Примітка
1	Функціональна специфікація програмного проєкту	24.03.2024	виконано
2	Проєктування програмного проєкту	29.03.2024	виконано
3	Кодування програмного проєкту	10.04.2024	виконано
4	Оформлення пояснювальної записки	14.05.2024	виконано
5	Захист курсової роботи		не виконано

Дата видачі завдання «13» березня 2024 р.

Керівник	_____________ ст. викл. Сокорчук І.П.
            (підпис)
Завдання прийняла до виконання ст. гр. ПЗПІ-21-7	
_____________ Кодола А. Т.
           (підпис)

 
РЕФЕРАТ


Пояснювальна записка до курсової роботи: 79 с., 40 рис., 3 табл., 3 додатків, 5 джерел.
ПРИВАТНІ КЛІНІКИ, ЗАПИС НА ПРИЙОМ, МЕДИЧНІ ЗАПИСИ, РОЗКЛАД, ПАЦІЄНТ, ЛІКАР, АДМІНІСТРАТОР, ПРОГРАМНА СИСТЕМА, МЕРЕЖА ПРИВАТНИХ КЛІНІК.

Об’єктом дослідження є сфера медичної індустрії, зосереджена на приватних клініках, де актуальні питання організації та керування їхньою роботою через програмні засоби.
Мета курсової роботи полягає в розробці програмної системи, яка забезпечить ефективне управління мережею приватних клінік. Система має надавати можливість створення та редагування інформації про клініки, лікарів, пацієнтів та їх медичні записи, а також керування записами на прийом.
Для реалізації цієї системи використовуються сучасні технології та інструменти, зокрема платформа NodeJS для розробки серверної частини, мова програмування JavaScript, фреймворк ExpressJS для створення веб-додатків, а також реляційна база даних MongoDB для зберігання та організації інформації. Для сканування QR-кодів використовується смарт-пристрій, розроблений за допомогою інструменту Node-RED, який базується на платформі NodeJS.
У результаті роботи розроблено програмну систему для організаціє та керування роботи мережі приватних клінік. Програмна система складається з веб-додатку, сервера та смарт-пристрою.
 
ЗМІСТ

ВСТУП	8
1 АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ	10
1.1	Бізнес-вимоги	10
1.1.1 Бізнес-можливості	10
1.2.1 Бізнес-цілі та критерії успіху	11
1.1.3 Потреби клієнтів або ринку	12
1.1.4 Бізнес-ризики	13
1.2	Концепція рішення	14
1.2.1 Окреслення концепції	15
1.2.2 Головна фукнціональність	16
1.2.3 Припущення та залежності	17
1.3	Рамки та обмеження проєкту	18
1.3.1 Рамки первинного випуску	18
1.3.2 Рамки наступних випусків	19
1.3.3 Обмеження та вийнятки	20
1.4	Бізнес-контекст	21
1.4.1 Профілі зацікавлених сторін	21
1.4.2 Пріоритети проєкту	23
1.4.3 Робоче середовище	24
2	ПОСТАНОВКА ЗАДАЧІ	26
3	АРХІТЕКТУРА ПРОГРАМНОЇ СИСТЕМИ	28
3.1 Серверна частина	28
3.1.1 Моделювання серверної частини	28
3.1.2 Проєктування бази даних	29
3.1.3 Архітектурні рішення та технології	30
3.1.4 Специфікація REST	31
3.2 Проєктування програмної частини IoT	34
3.2.1 Моделювання IoT-частини	34
3.2.2 Побудова діаграми взаємодії	35
3.2.3 Побудова діаграми діяльності	36
3.2.4 Побудова діаграми пакетів	37
3.2.5 Розробка IoT частини	38
3.3 Проектування клієнтської частини	38
3.3.1 Побудова діаграми компонентів	38
3.3.2 Побудова діаграми пакетів	39
3.3.3 Побудова діаграми станів	40
3.3.4 Розробка клієнтської частини	41
4	ОПИС ПРОГРАМНОЇ СИСТЕМИ	43
4.1 Запуск застосунку	43
4.2 Опис програмної реалізації для пацієнта	45
4.3 Опис програмної реалізації для лікаря	51
ВИСНОВКИ	60
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ	61
ДОДАТОК А	62
ДОДАТОК Б	69
ДОДАТОК В	71

 
ВСТУП


У сучасному світі медичні заклади, зокрема приватні клініки, відіграють важливу роль у забезпеченні населення якісною медичною допомогою. Управління мережею приватних клінік є складним завданням, що потребує системного та професійного підходу. Предметна область управління мережею приватних клінік охоплює широкий спектр аспектів, пов'язаних з організацією, функціонуванням і розвитком медичних закладів. На шляху до успішної реалізації медичної практики та забезпечення високого стандарту медичного обслуговування стикаються з різноманітними викликами, такими як координація прийому пацієнтів, управління медичним персоналом, фінансове планування, а також забезпечення безпеки та конфіденційності медичної інформації.
Зростання кількості пацієнтів та їхніх різноманітних потреб ставить під сумнів ефективність традиційних методів управління. Відстеження записів на прийом, розкладів лікарів, спеціальних запитів та інших аспектів вимагає систематизації та автоматизації. Облік оплати послуг, витрат на медичні матеріали, оплату праці персоналу та інших витрат вимагає точності та системності.
Організація розкладу лікарів та обслуговування пацієнтів вимагає уважного планування та координації. Важливо забезпечити рівномірне навантаження на медичний персонал та уникнути переповнення або нестачі лікарів.
Відсутність систематизованого та ефективного підходу до цих аспектів може призвести до збитків, втрати довіри пацієнтів та зниження якості медичної допомоги. Тому виникає необхідність у створенні програмної системи, яка б допомогла мережі приватних клінік ефективно керувати всіма аспектами їхньої діяльності, починаючи від планування прийому пацієнтів та закінчуючи аналізом фінансових показників. Така програмна система має на меті спростити та оптимізувати рутинні процеси, пов'язані з управлінням медичними закладами, забезпечуючи керівникам та адміністраторам зручний інструмент для організації медичної діяльності та забезпечення високого стандарту надання медичних послуг.

 
1 АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ
1.1	Бізнес-вимоги
1.1.1 Бізнес-можливості


На ринку існує кілька програмних рішень для управління мережею приватних клінік. Розглянемо деякі з них та їхні переваги та недоліки.
ЕМСІ - це програмне рішення, спеціалізоване на управлінні медичними закладами. ЕМСІ пропонує інструменти для ефективного управління пацієнтською базою, створення та відстеження медичних записів, а також аналітичні засоби для прийняття стратегічних рішень. Перевагою є простота використання та можливість інтеграції з іншими системами, але деякі користувачі відзначають недостатню гнучкість у налаштуваннях.
Medstar - це одна з провідних українських платформ для управління медичними закладами. Medstar надає широкий спектр функцій, включаючи електронні медичні записи, планування розкладів, управління фінансами та пацієнтами. Переваги включають велику функціональність та локалізацію під українські потреби, але може бути складною у використанні та вимагати значних фінансових вкладень.
Health24 - це програмне рішення, яке спеціалізується на управлінні медичними закладами. Health24 пропонує інструменти для управління пацієнтською базою, планування прийомів, електронні медичні записи та аналітику. Перевагою є зручність використання та адаптація до потреб медичних закладів. Однак система може не мати достатньо функцій для великих медичних мереж.
Наша програмна система відрізнятиметься наступними особливостями та перевагами. Вона матиме широкий функціонал та можливості налаштування, розроблені з урахуванням потреб кожної клініки, забезпечуючи гнучкість. Інтуїтивний інтерфейс дозволить користувачам швидко освоїти систему без тривалого навчання. Високий рівень інтеграції забезпечить легкість з'єднання з іншими системами, що сприятиме безперервному потоку інформації. Забезпечення конфіденційності та безпеки даних відповідатиме найвищим стандартам, особливо у сфері медичної інформації. Конкурентна вартість забезпечить оптимальне співвідношення ціни та якості, роблячи наше рішення доступним для різних за розміром медичних закладів. 


1.2.1 Бізнес-цілі та критерії успіху


BO-1: Забезпечення ефективного управління всіма аспектами діяльності мережі приватних клінік, включаючи прийом пацієнтів, управління медичним персоналом, фінансове планування та забезпечення безпеки медичної інформації.
BO-2: Оптимізація рутинних процесів, пов'язаних з управлінням клініками, для зниження витрат часу та ресурсів.
BO-3: Підвищення якості медичної допомоги та показників задоволеності пацієнтів через вдосконалення організації медичного процесу та впровадження інноваційних підходів.
SC-1: Збільшення кількості прийомів пацієнтів у кожній клініці мережі на 20% протягом першого року роботи програмної системи.
SC-2: Підвищення ефективності використання ресурсів клініки, що призведе до зменшення витрат на адміністрування на 15% протягом перших 6 місяців.
SC-3: Зниження часу очікування пацієнтів на прийом до 20% завдяки оптимізації розкладу лікарів та організації робочого процесу.
SC-4: Збільшення рівня задоволеності пацієнтів на 25% за рахунок покращення комунікації з клінікою та зручності використання сервісів програмної системи.


1.1.3 Потреби клієнтів або ринку


У програмній системі для управління мережею приватних клінік можуть бути два основних типи клієнтів: адміністратори та персонал клінік, пацієнти.
Потреби для пацієнтів:
-	швидкий та зручний доступ до розкладу прийому та медичних послуг через мобільний додаток або веб-платформу;
-	можливість онлайн-бронювання прийому та процедур для уникнення зайвого очікування та забезпечення зручності у виборі часу та лікаря;
-	здатність переглядати особисті медичні дані, включаючи медичну історію, результати аналізів та призначення, через особистий кабінет з максимальною конфіденційністю та безпекою;
-	отримання сповіщень про нагадування про майбутні прийоми, результати аналізів та будь-які зміни у розкладі лікарів для підтримки та мотивації.

Потреби для адміністратора та персоналу:
-	можливість відстежувати та вести медичну історію пацієнтів та інші аспекти активності;
-	 планування розкладів лікарів та прийому пацієнтів для оптимізації використання ресурсів клініки та уникнення перевантажень або затримок;
-	здатність отримувати звіти про ефективність роботи клініки, фінансовий стан та інші ключові показники для прийняття обґрунтованих стратегічних рішень;
-	забезпечення безпеки та конфіденційності медичної інформації, включаючи ведення захисту даних та дотримання вимог законодавства про захист персональних даних.


1.1.4 Бізнес-ризики


Програмна система для управління мережею приватних клінік має певні ризики, які можуть вплинути на успішність та стабільність системи:
-	можливість відмови системи може виникнути через апаратні або програмні збої, що призведе до перерв у роботі та втрати даних;
-	недостатня захищеність системи може призвести до кібератак, витоку конфіденційної інформації та порушення довіри користувачів;
-	неправильна адаптація системи до потреб клінік може призвести до низької прийнятності та невідповідності вимогам користувачів;
-	зростання конкуренції на ринку програмних рішень для медичних закладів може призвести до втрати ринкової позиції та зменшення прибутковості;
-	недоліки у функціоналі або якості підтримки можуть призвести до незадоволення користувачів та втрати довіри до системи; 
-	низький рівень задоволення користувачів від використання системи може призвести до втрати клієнтів та негативного впливу на репутацію бізнесу.

Для мінімізації цих ризиків необхідно приділити належну увагу заходам безпеки та надійності системи, забезпечити регулярне оновлення програмного забезпечення для виправлення потенційних вразливостей, а також проводити регулярні аудити безпеки для виявлення та усунення можливих загроз. Важливо також активно слідкувати за змінами на ринку програмних рішень та вчасно адаптувати систему до потреб користувачів, надавати якісну та оперативну підтримку, а також вдосконалювати функціонал з урахуванням зворотного зв'язку від користувачів.


1.2	Концепція рішення
1.2.1 Окреслення концепції


Програмна система для мережі приватних клінік розроблена для поліпшення управління медичними установами та підвищення якості надання медичних послуг. Головна ціль системи – полегшити роботу медичного персоналу, підвищити зручність для пацієнтів і оптимізувати адміністративні процеси.
Система повинна надавати можливість швидкого та легкого доступу до даних про пацієнтів, їх медичні історії, графіки прийомів та фінансові транзакції. Вона повинна сприяти ефективному розподілу робочого часу лікарів, оптимізації використання ресурсів клініки та забезпечує належне управління розкладом.
Фінансовий менеджмент клінік стане прозорим і ефективним завдяки автоматизації обліку оплати послуг, витрат на матеріали та зарплат персоналу. Система також буде пропонувати детальну аналітику та звітність для прийняття обґрунтованих рішень. 
Пацієнти отримують доступ до зручного онлайн-сервісу для запису на прийом, перегляду своїх медичних даних та отримання сповіщень про майбутні візити.
Безпека даних є критично важливим аспектом, тому система повинна забезпечити високий рівень захисту медичної інформації пацієнтів та інших конфіденційних даних від несанкціонованого доступу. Система має бути легко взаємодіяти з існуючими бізнес-системами клінік, такими як бухгалтерські програми та платіжні системи, забезпечуючи обмін даними та мінімізуючи потребу у повторному введенні інформації.
Ця програмна система спрямована на те, щоб стати необхідним ресурсом для керівників та адміністративного персоналу приватних клінік, допомагаючи їм в управлінні клінікою, поліпшенні обслуговування пацієнтів та забезпеченні стабільної роботи медичних закладів.


1.2.2 Головна фукнціональність


MF-1: Онлайн-запис та бронювання: забезпечення зручного онлайн-запису пацієнтів на прийом до лікарів, можливість вибору зручного часу та лікаря.
MF-2: Електронні медичні записи: Безпечне зберігання та доступ до медичних записів пацієнтів, що спрощує роботу лікарів.
MF-3: Управління розкладом: Лікарі та адміністративний персонал можуть автоматично планувати та коригувати свої робочі графіки.
MF-4: Персональний кабінет пацієнта: Пацієнти можуть переглядати свої медичні записи.
MF-5: Проведення оплати: Ведення обліку оплат за медичні послуги та управління рахунками.
MF-6: Керування клініками: Адміністратори мають можливість створювати, редагувати та видаляти клініки.
MF-7: Безпека даних: Забезпечення надійного захисту конфіденційної інформації пацієнтів від несанкціонованого доступу та витоків.
MF-8: Керування користувачами: Адміністратори мають можливість створювати, редагувати та видаляти користувачів системи.


1.2.3 Припущення та залежності


П-1: Усі користувачі системи, включаючи медичний персонал, адміністраторів та пацієнтів, мають доступ до інтернету для використання веб-інтерфейсу або мобільного додатку.
П-2: Медичний персонал і адміністратори мають базові навички роботи з комп'ютером і зможуть швидко освоїти нову систему.
П-3: Пацієнти готові використовувати цифрові інструменти для запису на прийом, оплати послуг та комунікації з клініками.
П-4: Програмна система відповідає нормативним вимогам щодо зберігання та обробки медичної інформації, забезпечуючи конфіденційність та захист даних пацієнтів.
З-1: Стабільне інтернет-з’єднання для безперебійного доступу до онлайн-функцій системи, таких як хмарне зберігання даних та онлайн-оплати.
З-2: Наявність технічної інфраструктури в клініках для підтримки та ефективного використання програмної системи.
З-3: Відповідність системи до нормативних вимог щодо зберігання та обробки медичної інформації, що регулюються місцевим законодавством.
З-4: Наявність підтримки з боку керівництва клінік для впровадження та використання нової програмної системи, що включає фінансові та організаційні ресурси.


1.3	Рамки та обмеження проєкту
1.3.1 Рамки первинного випуску


Програмна система складається з чотирьох компонентів: серверного, IoT, front-end і мобільного.
Серверна частина (back-end) включатиме в себе:
–	реєстрація та авторизація користувачів: реалізація можливості реєструватися та авторизуватися, підтримуючи різні ролі (пацієнти, лікарі, адміністративний персонал);
–	управління медичними записами: створення, редагування, зберігання та видалення електронних медичних записів пацієнтів;
–	онлайн-запис та бронювання: реалізація функціоналу для зручного онлайн-запису пацієнтів на прийом до лікарів;
–	управління розкладом: автоматизоване планування та коригування робочих графіків лікарів та адміністративного персоналу;
–	фінансовий облік: облік оплат за медичні послуги та управління рахунками;
–	управління клініками: створення, редагування, зберігання та видалення клінік;
–	безпека даних: захист конфіденційної інформації пацієнтів та забезпечення безпечного зберігання даних.

Клієнтська частина (front-end) включатиме в себе:
–	реєстрація та авторизація користувачів: сторінки для реєстрації та авторизації користувачів;
–	управління медичними записами: інтерфейс для лікарів та адміністративного персоналу для доступу до медичних записів;
–	онлайн-запис та бронювання: інтерфейс для пацієнтів для запису на прийом до лікарів;
–	персональний кабінет пацієнта: інтерфейс для пацієнтів, де вони можуть переглядати свої медичні записи, історію візитів та фінансовий стан;
–	управління розкладом: інтерфейс для лікарів та адміністративного персоналу для керування розкладами лікарів;
–	управління клініками: інтерфейс для адміністраторів для керування даними клініки;
–	адмін-панель: панель для адміністративного персоналу для управління користувачами, даними системи та звітами.

IoT частина включатиме в себе:
–	Wi-Fi модуль: наявність модулю Wi-Fi для підключення системи до мережі Інтернет, що дозволяє взаємодію із серверами та збереженням даних;
–	NFC датчики: застосування NFC-технології для отримання інформації з медичних записів пацієнтів для лікарів. 


1.3.2 Рамки наступних випусків 


У майбутньому наш проект буде розширюватися, а також буде впроваджено нові функції та можливості.

Клієнтська частина (Front-end):
–	відображення графіків і аналітики здоров'я на основі введених даних;
–	функція віддаленого консультування: додавання можливості проведення онлайн-консультацій з лікарем через веб-версію або мобільний додаток;
–	реалізація системи збереження історії консультацій та рецептів.

Серверна частина (back-end):
-	реалізація інструментів для аналізу даних з медичних карт пацієнтів з метою виявлення тенденцій та ризикових груп;
-	розробка алгоритмів прогнозування і попередження захворювань на основі аналізу історії захворювань пацієнтів.

IoT частина:
–	система відстеження фізичної активності: впровадження сенсорів, які можуть відстежувати рівень активності пацієнта та передавати ці дані в програмну систему для аналізу;
–	розробка алгоритмів виявлення несприятливих тенденцій у фізичній активності та надання порад для поліпшення здоров'я;
–	впровадження системи аналізу отриманих даних та надання рекомендацій для поліпшення стану здоров'я.


1.3.3 Обмеження та вийнятки


Обмеження:
-	необхідність підключення до інтернету: система потребує підключення до мережі Інтернет для коректної роботи користувачів;
-	обмежена підтримка старих пристроїв: деякі старі моделі смартфонів та компьютерів можуть не мати достатніх ресурсів для коректної роботи додатку;
-	не підтримуються старі версії операційних систем: деякі застарілі версії операційних систем можуть бути несумісні з додатком через відсутність необхідних функцій або бібліотек.


Винятки:
-	непередбачені обставини: деякі непередбачені обставини, такі як природні катастрофи, політичні кризи або інші події, можуть призвести до недоступності або обмеження функціональності додатку;
-	дії користувачів: використання додатку може бути обмеженим або недоступним у разі порушення користувачами умов користування або правил безпеки;
-	технічні збої на сервері: непередбачувані технічні проблеми на сервері можуть призвести до недоступності додатку для всіх користувачів.


1.4	Бізнес-контекст
1.4.1 Профілі зацікавлених сторін


Таблиця 1 – Профілі зацікавлених сторін проекту
Зацікавлена сторона	Основна цінність	Ставлення	Основні інтереси	Обмеження
Пацієнти	Швидкий та зручний доступ до медичної допомоги	Очікують зручний та зрозумілий інтерфейс	Можливість онлайн-запису до лікаря в зручний час, можливість перегляду своїх медичних записів, надійні нагадування про прийоми	Обмежена підтримка старих версій програмного забезпечення, обмеження доступу до інформації у разі технічних збоїв
Медичний персонал	Ефективне управління пацієнтами та їхніми медичними записами	Позитивно налаштовані, але очікують високу зручність використання	Зручне управління розкладами прийому пацієнтів, доступ до медичних записів, можливість редагування та оновлення інформації	Технічні збої на сервері, відсутність доступу до медичних записів у разі відключення Інтернету
Розробник проєкту	Розробка та підтримка функціоналу додатку	Орієнтовані на якість та дотримання строків	Розробка нових функцій, регулярне випуск оновлень, швидке усунення помилок та уразливостей	Обмежений бюджет, технічні обмеження
Інвестори	Прибуток від інвестицій та успішність проєкту	Вбачають продукт як перспективний для інвестування	Оцінка прибутковості інвестицій, збільшення вартості акцій, стабільність та зростання проєкту	Ризики інвестування, зміни в законодавстві та регулятивному середовищі


1.4.2 Пріоритети проєкту


Таблиця 2 – Пріоритети проєкту
Показник	Виконання (етапи)	Обмеження (граничні значення)	Ступінь свободи (допустимий діапазон)
План робіт	Версія 1.0 проєкту повинна бути випущена до 08.06.2024 р.		Можливе відхилення від графіку на 1 місяць
Функціональність			75% функцій повинні працювати на релізі 1.0
Якість			Версія 1.0 повинна пройти 95-100% тестувань
Персонал		Максимальний розмір команди – один розробник та тестувальник	
Ціна		9000 грн	Допустиме відхилення бюджету на 20%


1.4.3 Робоче середовище


Програмна система роботи мережі приватних клінік буде використовувати хмарний сервіс Amazon Web Services (AWS). AWS може забезпечити масштабованість, надійність і безпеку, надаючи широкий спектр хмарних обчислювальних, сховищ даних та інших сервісів. 
Для зберігання великого обсягу даних система буде використовувати базу даних MongoDB. MongoDB дозволяє зберігати дані в гнучких схемах, що дозволяє швидко змінювати структуру даних у відповідь на вимоги додатку. 
Захист персональних даних користувачів буде забезпечений відповідно до вимог регламенту GDPR.
Для серверної частини системи буде використовуватися платформа Node.js та Express.js. Node.js дозволяє виконувати JavaScript на стороні сервера, а Express.js надає різноманітні інструменти та функції для швидкого створення веб-серверів та API. 
Для клієнтської частини системи буде використано технології, такі як HTML, CSS та JavaScript, а також буде використано бібліотеку React.
Для розробки IoT частини системи буде використовуватися платформа Arduino з Wi-Fi модулями та NFC. Arduino IDE буде використовуватися для програмування системи мовою програмування C++.
 
2	ПОСТАНОВКА ЗАДАЧІ


Розглянувши предметну область можна дійти висновку, що основним завданням курсової роботи було створення програмної системи для керування робочого процесу мережею приватних клінік. 
Можна визначити ключові вимоги до програмної системи:
1.	Пацієнту повинні бути доступні наступні можливості:
-	реєстрація
-	авторизація;
-	перегляд та редагування особистого облікового запису;
-	перегляд особистих записів на прийом;
-	перегляд особистих медичних данних;
-	можливість створення запису на прийом до лікаря.
2.	Лікарю повинні бути доступні наступні можливості:
-	реєстрація;
-	авторизація;
-	перегляд та редагування особистого облікового запису;
-	перегляд розкладу лікарів;
-	перегляд записів на прийом пацієнтів;
-	перегляд медичних записів пацієнтів;
-	створення, видалення та редагування медичних записів;
-	сканування QR-коду.
3.	Адміністратору повинні бути доступні наступні можливості:
-	реєстрація;
-	авторизація;
-	перегляд та редагування особистого облікового запису;
-	створення, редагування та видалення розкладів лікарів;
-	експортування розкладів лікарів;
-	створення, редагування та видалення користувачів системи;
-	створення, редагування та видалення клінік;
-	перегляд медичних записів пацієнтів.

 
3	АРХІТЕКТУРА ПРОГРАМНОЇ СИСТЕМИ
3.1 Серверна частина
3.1.1 Моделювання серверної частини


Для розробки діаграми прецедентів у системі були виділені такі актори: пацієнт, лікар та адміністратор.
Створена UML діаграма прецедентів для взаємодії цих ролей системи наведена на рисунку 3.1.

 
Рисунок 3.1 - UML діаграма прецедентів для серверної частини

Отже, було створено діаграму прецедентів для ролей системи, яка описує взаємодію користувачів в системі та функції, які вони можуть виконувати.


3.1.2 Проєктування бази даних


Для проєктування бази даних було розроблено ER-модель даних (наведена на рис. 3.2). Були виделені такі сутності  системі: 
-	користувач (User): містить дані про усіх користувачів системи (пацієнтів, лікарів, адміністраторів);
-	клініка (Clinic): містить дані про усі клініки системи;
-	медичні записи (MedicalRecord): містить медичні записи пацієнтів, включаючи їх симптоми, діагнози та лікування;
-	розклад (Schedule): містить розклад усіх лікарів з індивідуальними часами роботи;
-	запис на прийом (Appointment): містить інформацію про запис на прийом пацієнтів до лікарів, включаючи вибір додаткових послуг;
-	клініка (Clinic): містить дані про усі приватні клініки системи;
-	облік рахунків (Invoice): містить облік усіх платежів та рахунків клінік.

 
Рисунок 3.2 – ER-діаграма даних серверної частини програмної системи

Таким чином, було розроблено ER-модель даних, яка показує структуру бази даних системи та взаємозв’язок між сутностями.


3.1.3 Архітектурні рішення та технології


Для розробки серверної частини програмної системи було обрано програмну платформу Node.js та веб-фреймворк Express.js для зручного створення API та маршрутизації, які використовують мову програмування JavaScript. Середовище розробки – WebStorm. 
Для зберігання даних була обрана база даних MongoDB. Доступ до бази даних з серверного застосунку здійснюється безпосередньо через MongoDB драйвер для Node.js, що забезпечує швидкий доступ та масштабованість.
На рисунку 3.3 показано розроблену діаграму розгортання.

 
Рисунок 3.3 – Діаграма розгортання для серверної частини програмної системи

Таким чином, було створено діаграму розгортання, яка показує, як компоненти системи фізично розташовані та взаємодіють між собою.


3.1.4 Специфікація REST


Для взаємодії серверу з іншими програмними частинами використовується Rest API. Опис специфікації Rest API наведено в таблиці 3.1.

Таблиця 3.1 - Опис специфікація REST API
URL	Метод HTTP	Ролі доступу	Призначення
/api/users/register	POST	Всі користувачі	Реєстрація користувача в системі
/api/users/login	POST	Всі користувачі	Вхід в обліковий запис системи
/api/users/update/:id	PUT	Адміністратор	Редагування даних облікового запису користувача
/api/users/delete/:id	DELETE	Адміністратор	Видалення облікового запису користувача 
/api/users/all	GET	Адміністратор	Отримання усіх користувачів системи
/api/users/profile	GET	Всі користувачі	Отримання даних облікового запису користувача
/api/users/:id		GET	Всі користувачі Отримання даних певного користувача
/api/users/patients	GET	Адміністратор	Отримання даних усіх пацієнтів
/api/users /doctors	GET	Адміністратор	Отримання даних усіх докторів
/api/medical-records/all	GET	Лікар, Адміністратор	Отримання усіх медичних записів пацієнтів
/api/medical-records/create	POST	Лікар	Створення нового медичного запису пацієнта
/api/medical-records/update/:id	PUT	Лікар	Редагування медичного запису пацієнта
/api/medical-records/delete/:id	DELETE	Лікар	Видалення медичного запису пацієнта
/api/medical-records/:id	GET	Лікар	Отримання інформації певного медичного запису
/api/appointments/all		GET	Адміністратор	Отримання усіх записів на прийом
/api/appointments/create	POST	Користувач	Створення запису на прийом до лікаря
/api/appointments/update/:id	PUT	Адміністратор	Редагування запису на прийом 
/api/appointments/delete/:id	DELETE	Адміністратор	Видалення запису на прийом
/api/appointments/doctor/:id	GET	Лікар	Отримання списку записів на прийом до конкретного лікаря 
/api/schedules/create	POST	Адміністратор	Створення розкладу роботи для лікаря
/api/schedules/update/:id	PUT	Адміністратор	Редагування розкладу роботи лікаря
/api/schedules/delete/:id	DELETE	Адміністратор	Видалення розкладу роботи лікаря
/api/schedules/all	GET	Адміністратор, Лікар	Отримання розкладу усіх лікарів
/api/finances/create	POST	Адміністратор	Створення рахунку
/api/finances/update/:id	PUT	Адміністратор	Редагування рахунку
/api/finances/delete/:id	DELETE	Адміністратор	Видалення рахунку
/api/finances/all	GET	Адміністратор	Отримання усіх рахунків
/api/clinics/all	GET	Адміністратор	Отримання усіх клінік
/api/clinics/create	POST	Адміністратор	Створення клініки
/api/clinics/:id	GET	Адміністратор	Отримання певної клініки
/api/clinics/edit/:id	PUT	Адміністратор	Редагування інформації про клініку
/api/clinics/delete/:id	DELETE	Адміністратор	Видалення інформації про клініку
 
Отже, за допомогою таблиці специфікації REST було визначено кінцеві точки для запитів для розробленого серверного застосунку.


3.2 Проєктування програмної частини IoT
3.2.1 Моделювання IoT-частини


Для розробки діаграми прецедентів для ІОТ частини у системі були виділені такі актори: пацієнт, лікар.
Створена UML діаграма прецедентів для взаємодії цих ролей системи наведена на рисунку 3.4.


Рисунок 3.4 - UML діаграма прецедентів для ІоТ частини

Отже, було створено діаграму прецедентів для ролей системи, яка показує, що після запису пацієнта на прийом до лікаря, лікар має можливість продивитися список записів на прийом, які мають QR-код для отримання інформації з медичних даних відповідного пацієнта.


3.2.2 Побудова діаграми взаємодії


Для подальшої розробки IoT системи було визначено взаємодію між системою та IoT пристроєм. Цю взаємодію було зображено на діаграмі взаємодії (рис. 3.5).

 
Рисунок 3.5 – Діаграма взаємодії між системою та ІоТ

Таким чином, на діаграмі взаємодії ми бачимо, що система здійснює запит до ІоТ за QR-кодом пацієнта для отримання інформації з медичних даних. Після отримання цього QR-коду, система відправляє його на ІоТ. ІоТ приймає отриманий QR-код від системи та сканує його. Після успішного сканування QR-коду, система здійснює запит до ІоТ за медичними записами пацієнта на основі отриманого QR-коду. Після отримання медичних записів, система їх відображає у відповідному розділі інтерфейсу користувача.


3.2.3 Побудова діаграми діяльності


Для визначення процесу використання IOT частини в програмній системі було реалізовано діаграму діяльності (рис. 3.6).

 
Рисунок 3.6 - UML діаграма діяльності

Отже, на діаграмі бачимо, що коли генерується QR-код, зчитувач дешифрує його і відправляє отриманні дані на сервер. Якщо помилок немає, то лікар отримає медичні записи пацієнта.


3.2.4 Побудова діаграми пакетів


За допомогою діаграми пакетів (рис. 3.7) можна побачити структуру і зв’язки між пакетами.

 
Рисунок 3.7 – Діаграма пакетів

З даної діаграми можна виділити такі пакети: HTTP In, який отримує http-запитів від серверу, Function – пакет, який відповідає за логіку обробки даних,  HTTP response відправляє відповідь сканеру.


3.2.5 Розробка IoT частини


Для розробки IOT частини програмної системи було використано інтерфейс Node-RED. 
Для взаємодії з зчитувачем QR-коду було використано http-вузли, які відправляли запити на сервер. Функція, у свою чергу, отримує дані з QR-коду і перетворює їх на формат JSON, які потім відправляє на сервер.


3.3 Проектування клієнтської частини
3.3.1 Побудова діаграми компонентів


Для проектування клієнтської частини була розроблена UML діаграма компонентів (див. рис. 3.8), яка демонструє архітектуру системи та взаємодію її компонентів.

 
Рисунок 3.8 - Діаграма компонентів

Були виділені наступні компоненти:
-	Appointment – відображення доступних записів на прийом до лікарів для пацієнтів;
-	Clinic - відображення приватних клінік системи;
-	Payment – відображення рахунків пацієнтів з оплатою за прийоми до лікарів;
-	MedicalRecords – відображення медичних записів пацієнтів;
-	QR-code – відображення QR-code до кожного запису на прийом пацієнта;
-	QR-code-info – відображення отриманої інформації медичних записів пацієнта, який записався на прийом;
-	Schedule – відображення розкладу лікарів у клініках;
-	ExportSchedule – відображення експортування розкадів лікарів у вигляді PDF-файлу.


3.3.2 Побудова діаграми пакетів


Для розробки клієнтської частини було виділено пакети, які складають структуру програмної системи за допомогою Діаграми пакетів (рис. 3.9).

 
Рисунок 3.9 – Діаграма пакетів

Згідно діаграми можна побачити, що було виділено такі пакети:
-	src – основний пакет вихідного коду;
-	public – пакет із статичними файлами та файлами публічного доступу;
-	components – пакет компонентів архітектури проєкту;
-	styles – пакет зі стилями;
-	node_module – пакет, який містить сторонні бібліотеки та модулі;
-	assets – пакет статичних файлів.


3.3.3 Побудова діаграми станів


Для подальшої розробки клієнтської частини системи було визначено основні функції та інтерфейси за допомогою діаграми станів (див. рис. 3.10).
 
Рисунок 3.10 – Діаграма станів 

Таким чином, було реалізовано діаграму станів, яка показує поведінку клієнтської частини, що залежить від її поточного стану.


3.3.4 Розробка клієнтської частини


Для розробки клієнтської частини програмної системи було використано React.js, що використовує мову програмування Javascript.
Клієнтська частина надає графічний інтерфейс для відображення створеної бізнес логіки. 
‒	відображення доступних записів на прийом, можливість створення запису на прийом, можливість сплатити за відвідування, можливість перегляду історії запису на прийом для пацієнтів та лікарів;
‒	відображення профілю користувача, можливість редагувати його, видаляти дані користувачів для ролі адміністратора;
‒	відображення розкладу лікарів, можливість створення нового розкладу, редагування та видалення існуючого розкладу, а також можливість експортування розкладі лікарів у вигляді PDF-файлу;
‒	відображення медичних записів пацієнтів, можливість перегляду усіх медичних записів, а також створення, редагування та видалення медичних записів пацієнта для ролі лікаря;
‒	відображення клінік, можливість створення клініки, редагування інформації клініки та видалення;
‒	можливість сканування QR-коду, що знаходить у блоці записів на прийом до лікаря, який містить інформацію медичних записів відповідного пацієнта.
Відповідно до вимог захисту даних, паролі користувачів не відображаються при перегляді інформації користувачів. Паролі також хешуються, щоб сховати їх при відображені у базі даних. Крім цього під час авторизації кожному користувачу генерується його унікальний токен для кожної сесії, що реалізовано за допомогою jwt.


4	ОПИС ПРОГРАМНОЇ СИСТЕМИ

4.1 Запуск застосунку


Для запуску програми слід завантажити архів із репозиторію та відкрити вже завантажені файли у середовищі розробки, такому як WebStorm чи будь-яке інше.
Для запуску серверної частини системи необхідно запустити файл server.js. Після чого в терміналі середовища розробки з’явиться повідомлення про успішний запуск сервера та підключення до бази даних (див. рис. 4.1).

  
Рисунок 4.1 – Запуск серверної частини

Для запуску клієнтської частини переходимо до відповідної директорії, потім потрібно ввести у терміналі команду “npm start”. Після чого відкриється сторінка у браузері з програмою (див. рис. 4.2). 

  
Рисунок 4.2 – Запуск клієнтської частини

Для запуску IoT-пристрою потрібно встановити Node-RED. Відкриваємо консольний рядок та вводимо наступну команду «npm install -g --unsafe-perm node-red». Після цього потрібно запустити його за допомогою команди «node-red» (див. рис. 4.3).

  
Рисунок 4.3 – Запуск частини смарт-пристрою

Тепер переходимо за посиланням http://localhost:1880/, та експортуємо завантажений файл з репозиторію. Після чого розгорнути отриману систему вузлів (див. рис. 4.4).

  
Рисунок 4.4 – Розгорнута частина смарт-пристрою

Тепер застосунок повністю готовий до роботи. Можна відкрити сторінку клієнтської частини у браузері та розпочати роботу.


4.2 Опис програмної реалізації для пацієнта


Під час запуску клієнтської частини застосунку можна побачити сторінку авторизації (див. рис. 4.5), де можна увійти в систему, вказавши відповідні дані.  
  
 
Рисунок 4.5 – Сторінка авторизації

Також можна зареєструватися у системі та створити новий обліковий запис (див. рис. 4.6). Потрібно ввести ім’я користувача, пароль, електрону пошту, прізвище, ім’я та роль користувача.

 
Рисунок 4.6 – Сторінка реєстрації

Далі користувач потрапляє на головну сторінку сайту (див. рис. 4.7).


Рисунок 4.7 – Головна сторінка сайту

Користувач може переглянути особисті дані в обліковому записі, на який він може перейти обравши відповідний пункт у шапці сайту (див. рис. 4.8).

 
Рисунок 4.8 – Обліковий запис користувача

Користувач має можливість відредагувати свої особисті дані, заповнивши відповідну форму (див. рис. 4.9).


Рисунок 4.9 – Сторінка редагування облікового запису

Якщо користувач авторизувався у системі як пацієнт, то у шапці сайту він може побачити історію записів на прийом до лікарів, особисті медичні записи та можливість створення запису на прийом до лікаря (див. рис. 4.10).


Рисунок 4.10 – Сторінка з шапкою можливостей пацієнта

Пацієнт має можливість створити запис на прийом до лікаря, для цього потрібно обрати місто, клініку, лікаря, дату, час та послуги (див. рис. 4.11).


Рисунок 4.11 – Сторінка створення запису на прийом

Пацієнт може переглянути історію особистих записів на прийом до лікарів (див. рис. 4.12), де також можна одразу провести оплату.


Рисунок 4.12 – Сторінка історії запису на прийом до лікарів

Для проведення оплати потрібно заповнити форму (див. рис. 4.13), ввести номер картки, CVV та строк дії картки.


Рисунок 4.13 – Сторінка оплати

Також пацієнт може переглянути усі свої медичні записи, де вказано дата, час, діагноз, лікування тощо (див. рис. 4.14).


Рисунок 4.14 – Сторінка медичних записів

Було описано можливості взаємодії пацієнта з реалізованою програмною системою.


4.3 Опис програмної реалізації для лікаря


Якщо користувач зайшов у систему як лікар, то він має можливість переглянути розклад лікарів, записів пацієнтів на прийом до нього та медичних записів пацієнтів (див. рис. 4.15).


Рисунок 4.15 – Шапка сайту для лікаря

Лікар може продивитися розклад лікарів клініки (див. рис. 4.16).


Рисунок 4.16 – Сторінка розкладу лікарів

Також при перегляді записів на прийом, лікар має можливість відсканувати QR-код, який буде містити інформацію медичних записів пацієнта, який до нього записався (див. рис. 4.17).


Рисунок 4.17 – Сторінка записів на прийом до лікаря

Крім, цього лікар має можливісь переглядати медичні записи усіх пацієнтів (див. рис. 4.18), де він має можливість редагування, видалення та створення медичних записів.


Рисунок 4.18 – Сторінка медичних записів пацієнтів

Для створення медичного запису, лікар повинен заповнити відповідну форму, з інформацією про скарги, встановлення діагнозу та лікування пацієнта (див. рис. 4.19).


Рисунок 4.19 – Сторінка створення медичного запису

Для редагування потрібно у формі вказати зміни до медичного запису (див. рис. 4.20).


Рисунок 4.20 – Сторінка редагування медичного запису

Було описано можливості взаємодії лікаря з реалізованою програмною системою.


4.4 Опис програмної реалізації для адміністратора


Якщо користувач увійшов у систему як адміністратор, то у шапці сайту він буде мати можливість переглядати та створювати розклад лікарів, керувати користувачами, переглядати медичні записи та керувати клініками (див. рис. 4.21).


Рисунок 4.21 – Шапка з доступним функціоналом для адміністратора

Адміністратор має можливість переглядати розклад лікарів, де він також має можливість створення, редагування, видалення та експортування розкладів (див. рис. 4.22).


Рисунок 4.22 – Сторінка для керування розкладами лікарів

Для створення розкладу лікаря, потрібно заповнити відповідну форму, де для лікаря вказати дату та час роботи (див. рис. 4.23).


Рисунок 4.23 – Сторінка створення розкладу лікаря

Для редагування розкладу лікаря потрібно вказати зміни у формі, яка містить інформацію про розклад (див. рис. 4.24).


Рисунок 4.24 – Сторінка редагування розкладу

При натисканні на кнопку експортування розкладу, створюється файл формату PDF, який завантажується на пристрій користувача (див. рис. 4.25).


Рисунок 4.25 – Сторінка PDF-файлу з розкладом лікарів

Адміністратор також має можливість керувати користувачами системи: редагувати та видаляти дані про користувачів (див. рис. 4.26).


Рисунок 4.26 – Сторінка керування користувачами

Для редагування користувача, адміністратору потрібно внести зміни у форму, де відображається дані користувачів (див. рис. 4.27).


Рисунок 4.27 – Сторінка редагування користувача

Крім цього, адміністратор має можливість керувати клініками: створювати, редагувати та видаляти (див. рис. 4.28).


Рисунок 4.28 – Сторінка керування клініками

Для створення клініки потрібно заповнити форму, де вказати назву клініки, місто, адресу, електронну пошту, номер телефону (див. рис. 4.29).


Рисунок 4.29 – Сторінка створення клініки

Для редагування клініки потрібно вказати зміни у формі з інформацією про клініку (див. рис. 4.30).


Рисунок 4.30 – Сторінка редагування клініки

Було описано можливості взаємодії адміністратора з реалізованою програмною системою.


ВИСНОВКИ


Під час виконання курсової роботи було реалізовано програмну систему на тему: «Програмна система роботи мережі приватних клінік».
Після аналізу предметної області була створена база даних. Програмна система включає серверну, клієнтську та IoT частини, які реалізовані за допомогою платформи NodeJS у поєднанні з фреймворком ExpressJS, бібліотекою React та інтерфейсом Node-RED для роботи зі смарт-пристроями.
Програмна система дає можливість користувачам керувати робочими процесами мережі приватних клінік. Це дає можливість зареєструватися и авторизуватися пацієнтам, лікарям та адміністраторам, керувати медичними записами пацієнтів, розкладом лікарів, клініками, записуватися на прийом до лікарів. Система дає можливість генерувати та сканувати Qr-код для зручного перегляду медичних записів пацієнтів, які записалися на прийом. Також система дозволяє експортувати розклад лікарів.
Була складена пояснювальна записка, що містить детальний опис проектування та реалізації програмної системи, та опис функціональності для пацієнтів, лікарів та адміністраторів.

 
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ


1.	JavaScript Info. URL: https://javascript.info (дата звернення: 10.05.2024);
2.	Node-RED. URL: https://nodered.org/docs/ (дата звернення 14.05.2024)
3.	React: Documentation. URL: https://legacy.reactjs.org/docs/getting-started.html (дата звернення 20.05.2024)
4.	Мартін Р. Чистий код: створення і рефакторинг за допомогою AGILE. – ФАБУЛА, 2019. – 416 с. (дата звернення 23.05.2024)
5.	Демонстрація курсової роботи. Відеозапис. URL: https://youtu.be/k3dzTKmdh_k

 
ДОДАТОК А
Код серверної частини програмної системи
А.1 Код файлу server.js


1 const express = require('express');
2 const cors = require('cors');
3 const connectDB = require('./database');
4 const mongoose = require('mongoose');
5 const dotenv = require('dotenv');
6 
7 // Імпорт маршрутів
8 const userRoutes = require('./routes/users');
9 const medicalRecordRoutes = require('./routes/medicalRecords');
10 const appointmentRoutes = require('./routes/appointments');
11 const scheduleRoutes = require('./routes/schedules');
12 const financeRoutes = require('./routes/finances');
13 const clinicRoutes = require('./routes/clinics');
14 
15 // Завантаження змінних середовища з .env файлу
16 dotenv.config();
17 
18 const app = express();
19 const PORT = process.env.PORT || 3000;
20 
21 // Підключення до бази даних MongoDB
22 mongoose.connect(process.env.MONGODB_URI, { useNewUrlParser: true, useUnifiedTopology: true })
23     .then(() => console.log('Connected to MongoDB'))
24     .catch(err => console.error('Could not connect to MongoDB', err));
25 
26 // Налаштування CORS для доступу з різних доменів
27 app.use(cors({
28     origin: 'http://localhost:3000',
29     methods: ['GET', 'POST', 'PUT', 'DELETE'],
30     allowedHeaders: ['Content-Type']
31 }));
32 app.use(express.json());
33 
34 app.use('/api/users', userRoutes);
35 app.use('/api/medical-records', medicalRecordRoutes);
36 app.use('/api/appointments', appointmentRoutes);
37 app.use('/api/schedules', scheduleRoutes);
38 app.use('/api/finances', financeRoutes);
39 app.use('/api/clinics', clinicRoutes);
40 
41 // Запуск сервера
42 app.listen(PORT, () => {
43     console.log(`Server is running on port ${PORT}`);
44 });

A.2 Код файлу, який містить маршрути для керування записами на прийом


1 const express = require('express');
2 const Appointment = require('../models/appointment');
3 const User = require('../models/User');
4 const Clinic = require('../models/Clinic');
5 const { jwtDecode } = require('jwt-decode');
6 const router = express.Router();
7 
8 const servicesPrices = {
9     "Consultation": 200,
10     "Ultrasound": 300,
11     "Blood Test": 150,
12     "X-Ray": 200
13 };
14 
15 // Створення запису
16 router.post('/create', async (req, res) => {
17     const { patient_id, doctor_id, appointment_date, appointment_time, services, clinic_id }  = req.body;
18 
19     try {
20         const patient = await User.findById(patient_id);
21         if (!patient || patient.role !== 'patient') {
22             return res.status(400).json({ error: 'Invalid patient ID' });
23         }
24 
25         const doctor = await User.findById(doctor_id);
26         if (!doctor || doctor.role !== 'doctor') {
27             return res.status(400).json({ error: 'Invalid doctor ID' });
28         }
29 
30         let totalPrice = servicesPrices["Consultation"];
31         services.forEach(service => {
32             if (servicesPrices[service]) {
33                 totalPrice += servicesPrices[service];
34             }
35         });
36 
37         const newAppointment = new Appointment({
38             patient_id,
39             doctor_id,
40             appointment_date,
41             appointment_time,
42             services,
43             clinic_id,
44             total_price: totalPrice
45         });
46 
47         await newAppointment.save();
48         res.status(201).json({ message: 'Appointment created successfully' });
49     } catch (error) {
50         console.error('Error creating appointment:', error);
51         res.status(500).json({ error: 'Failed to create appointment' });
52     }
53 });
54 
55 // Редагування запису
56 router.put('/update/:id', async (req, res) => {
57     const { id } = req.params;
58     const { patient_id, doctor_id, appointment_date, appointment_time } = req.body;
59 
60     try {
61         const appointment = await Appointment.findById(id);
62 
63         if (!appointment) {
64             return res.status(404).json({ error: 'Appointment not found' });
65         }
66 
67         if (patient_id) {
68             const patient = await User.findById(patient_id);
69             if (!patient) {
70                 return res.status(400).json({ error: 'Invalid patient ID' });
71             }
72             appointment.patient_id = patient_id;
73         }
74 
75         if (doctor_id) {
76             const doctor = await User.findById(doctor_id);
77             if (!doctor) {
78                 return res.status(400).json({ error: 'Invalid doctor ID' });
79             }
80             appointment.doctor_id = doctor_id;
81         }
82 
83         if (appointment_date) appointment.appointment_date = appointment_date;
84         if (appointment_time) appointment.appointment_time = appointment_time;
85 
86         await appointment.save();
87         res.status(200).json({ message: 'Appointment updated successfully' });
88     } catch (error) {
89         console.error('Error updating appointment:', error);
90         res.status(500).json({ error: 'Failed to update appointment' });
91     }
92 });
93 
94 // Видалення запису
95 router.delete('/delete/:id', async (req, res) => {
96     const { id } = req.params;
97 
98     try {
99         const result = await Appointment.deleteOne({ _id: id });
100 
101         if (result.deletedCount === 0) {
102             return res.status(404).json({ error: 'Appointment not found' });
103         }
104 
105         res.status(200).json({ message: 'Appointment deleted successfully' });
106     } catch (error) {
107         console.error('Error deleting appointment:', error);
108         res.status(500).json({ error: 'Failed to delete appointment' });
109     }
110 });
111 
112 router.get('/all', async (req, res) => {
113     try {
114         const appointments = await Appointment.find()
115             .populate('patient_id', 'first_name last_name email')
116             .populate('doctor_id', 'first_name last_name email')
117             .populate('clinic_id', 'name address');;
118 
119         res.status(200).json(appointments);
120     } catch (error) {
121         console.error('Error fetching appointments:', error);
122         res.status(500).json({ error: 'Failed to fetch appointments' });
123     }
124 });
125 
126 router.get('/doctor/:doctorId', async (req, res) => {
127     const { doctorId } = req.params;
128     const token = req.headers.authorization.split(' ')[1];
129     const { userId, role } = jwtDecode(token);
130 
131     try {
132         if (role === 'doctor' && userId === doctorId) {
133             const appointments = await Appointment.find({ doctor_id: doctorId })
134                 .populate('patient_id', 'first_name last_name email _id')
135                 .populate('doctor_id', 'first_name last_name email');
136 
137             res.status(200).json(appointments);
138         } else {
139             res.status(403).json({ error: 'Access denied' });
140         }
141     } catch (error) {
142         console.error('Error fetching doctor appointments:', error);
143         res.status(500).json({ error: 'Failed to fetch doctor appointments' });
144     }
145 });
146 
147 router.get('/:id', async (req, res) => {
148     const { id } = req.params;
149 
150     try {
151         const appointment = await Appointment.findById(id)
152             .populate('patient_id', 'first_name last_name email')
153             .populate('doctor_id', 'first_name last_name email');
154 
155         if (!appointment) {
156             return res.status(404).json({ error: 'Appointment not found' });
157         }
158 
159         res.status(200).json(appointment);
160     } catch (error) {
161         console.error('Error fetching appointment:', error);
162         res.status(500).json({ error: 'Failed to fetch appointment' });
163     }
164 });
165 
166 router.post('/pay', async (req, res) => {
167     const { appointmentId, cardNumber, cvv, expiryDate } = req.body;
168 
169     
170     if (cardNumber.length !== 16 || cvv.length !== 3) {
171         return res.status(400).json({ error: 'Invalid card details' });
172     }
173 
174     try {
175         const appointment = await Appointment.findById(appointmentId);
176         if (!appointment) {
177             return res.status(404).json({ error: 'Appointment not found' });
178         }
179 
180         
181         appointment.status = 'paid';
182         await appointment.save();
183 
184         res.status(200).json({ message: 'Payment successful', appointment });
185     } catch (error) {
186         console.error('Error processing payment:', error);
187         res.status(500).json({ error: 'Failed to process payment' });
188     }
189 });
190 
191 
192 // Обробка оплати
193 router.post('/pay/:id', async (req, res) => {
194     const { id } = req.params;
195 
196     try {
197         const appointment = await Appointment.findById(id);
198 
199         if (!appointment) {
200             return res.status(404).json({ error: 'Appointment not found' });
201         }
202 
203         appointment.status = 'paid';
204         await appointment.save();
205 
206         res.status(200).json({ message: 'Payment successful', appointment });
207     } catch (error) {
208         console.error('Error processing payment:', error);
209         res.status(500).json({ error: 'Failed to process payment' });
210     }
211 });
212 
213 router.get('/patient/:patient_id', async (req, res) => {
214     const { patient_id } = req.params;
215     const token = req.headers.authorization.split(' ')[1];
216     const { userId, role } = jwtDecode(token);
217 
218     try {
219         if (role === 'patient' && userId === patient_id) {
220             const appointments = await Appointment.find({ patient_id })
221                 .populate('patient_id', 'first_name last_name email')
222                 .populate('doctor_id', 'first_name last_name email')
223                 .populate('clinic_id', 'name address');
224             res.status(200).json(appointments);
225         } else {
226             res.status(403).json({ error: 'Access denied' });
227         }
228     } catch (error) {
229         console.error('Error fetching appointment history:', error);
230         res.status(500).json({ error: 'Failed to fetch appointment history' });
231     }
232 });
233 
234 
235 module.exports = router;


А.3 Код маршрутів для керування клініками


1 const express = require('express');
2 const Clinic = require('../models/Clinic');
3 const mongoose = require("mongoose");
4 const router = express.Router();
5 
6 // Створення нової клініки
7 router.post('/create', async (req, res) => {
8     const { name, city, address, phone, email } = req.body;
9 
10     try {
11         const newClinic = new Clinic({ name, city, address, phone, email });
12         await newClinic.save();
13         res.status(201).json({ message: 'Clinic created successfully' });
14     } catch (error) {
15         console.error('Error creating clinic:', error);
16         res.status(500).json({ error: 'Failed to create clinic' });
17     }
18 });
19 
20 // Отримання списку всіх клінік
21 router.get('/all', async (req, res) => {
22     try {
23         const clinics = await Clinic.find({});
24         res.status(200).json(clinics);
25     } catch (error) {
26         console.error('Error fetching clinics:', error);
27         res.status(500).json({ error: 'Failed to fetch clinics' });
28     }
29 });
30 
31 // Отримання клініки по ід
32 router.get('/:id', async (req, res) => {
33     try {
34         const clinicId = req.params.id;
35 
36         // Перевірка на валідність ObjectId
37         if (!mongoose.Types.ObjectId.isValid(clinicId)) {
38             return res.status(400).json({ error: 'Invalid clinic ID format' });
39         }
40 
41         const clinic = await Clinic.findById(clinicId);
42 
43         if (!clinic) {
44             return res.status(404).json({ error: 'Clinic not found' });
45         }
46 
47         res.status(200).json(clinic);
48     } catch (error) {
49         console.error('Error fetching clinic:', error);
50         res.status(500).json({ error: 'Failed to fetch clinic' });
51     }
52 });
53 
54 
55 // Редагування клініки за ID
56 router.put('/edit/:id', async (req, res) => {
57     const { id } = req.params;
58     const { name, city, address, phone, email } = req.body;
59 
60     try {
61         const clinic = await Clinic.findByIdAndUpdate(id, { name, city, address, phone, email }, { new: true });
62         if (!clinic) {
63             return res.status(404).json({ error: 'Clinic not found' });
64         }
65         res.status(200).json({ message: 'Clinic updated successfully' });
66     } catch (error) {
67         console.error('Error updating clinic:', error);
68         res.status(500).json({ error: 'Failed to update clinic' });
69     }
70 });
71 
72 // Видалення клініки за ID
73 router.delete('/delete/:id', async (req, res) => {
74     const { id } = req.params;
75 
76     try {
77         const clinic = await Clinic.findByIdAndDelete(id);
78         if (!clinic) {
79             return res.status(404).json({ error: 'Clinic not found' });
80         }
81         res.status(200).json({ message: 'Clinic deleted successfully' });
82     } catch (error) {
83         console.error('Error deleting clinic:', error);
84         res.status(500).json({ error: 'Failed to delete clinic' });
85     }
86 });
87 
88 module.exports = router;


ДОДАТОК Б
Код IoT-частини програмної системи
Б.1 Код файлу node-red-qr-code-scan-flows.json


1 [
2     {
3         "id": "1950867e25cf4b95",
4         "type": "tab",
5         "label": "Scan QR Code",
6         "disabled": false,
7         "info": "",
8         "env": []
9     },
10     {
11         "id": "9e103dc0f0628f59",
12         "type": "http in",
13         "z": "1950867e25cf4b95",
14         "name": "",
15         "url": "/scan-qr",
16         "method": "post",
17         "upload": true,
18         "swaggerDoc": "",
19         "x": 110,
20         "y": 100,
21         "wires": [
22             [
23                 "6ab4f7ff4827b11a",
24                 "f0cfe25843d44a1b"
25             ]
26         ]
27     },
28     {
29         "id": "f0cfe25843d44a1b",
30         "type": "function",
31         "z": "1950867e25cf4b95",
32         "name": "Process QR Data",
33         "func": "msg.payload = msg.payload.URL;\nreturn msg;",
34         "outputs": 1,
35         "timeout": 0,
36         "noerr": 0,
37         "initialize": "",
38         "finalize": "",
39         "libs": [],
40         "x": 390,
41         "y": 100,
42         "wires": [
43             [
44                 "0c628e6d46ca99cd",
45                 "e88453d4422860c8"
46             ]
47         ]
48     },
49     {
50         "id": "6ab4f7ff4827b11a",
51         "type": "debug",
52         "z": "1950867e25cf4b95",
53         "name": "debug 4",
54         "active": true,
55         "tosidebar": true,
56         "console": false,
57         "tostatus": false,
58         "complete": "false",
59         "statusVal": "",
60         "statusType": "auto",
61         "x": 300,
62         "y": 180,
63         "wires": []
64     },
65     {
66         "id": "0c628e6d46ca99cd",
67         "type": "debug",
68         "z": "1950867e25cf4b95",
69         "name": "debug 5",
70         "active": true,
71         "tosidebar": true,
72         "console": false,
73         "tostatus": false,
74         "complete": "false",
75         "statusVal": "",
76         "statusType": "auto",
77         "x": 600,
78         "y": 160,
79         "wires": []
80     },
81     {
82         "id": "e88453d4422860c8",
83         "type": "http response",
84         "z": "1950867e25cf4b95",
85         "name": "",
86         "statusCode": "",
87         "headers": {},
88         "x": 790,
89         "y": 100,
90         "wires": []
91     }
92 ]


 
ДОДАТОК В
Код клієнтської частини програмної системи
В.1 Код файлу, де описано структуру маршрутів App.js


1 import React from 'react';
2 import { BrowserRouter as Router, Route, Routes } from 'react-router-dom';
3 import Header from './components/Header/Header';
4 import Footer from './components/Footer/Footer';
5 import Register from './components/Register/Register';
6 import Login from './components/Login/Login';
7 import Home from './components/Home/Home';
8 import Profile from './components/Profile/Profile';
9 import ProtectedRoute from './ProtectedRoute';
10 import CreateMedicalRecord from './components/CreateMedicalRecord/CreateMedicalRecord';
11 import MedicalRecordList from './components/MedicalRecordList/MedicalRecordList';
12 import EditMedicalRecord from './components/EditMedicalRecord/EditMedicalRecord';
13 import CreateSchedule from './components/CreateSchedule/CreateSchedule';
14 import ScheduleList from './components/ScheduleList/ScheduleList';
15 import EditSchedule from './components/EditSchedule/EditSchedule';
16 import CreateAppointment from './components/CreateAppointment/CreateAppointment';
17 import AppointmentHistory from './components/AppointmentHistory/AppointmentHistory';
18 import DoctorAppointments from './components/DoctorAppointment/DoctorAppointments';
19 import UserList from './components/UserList/UserList';
20 import EditUser from './components/EditUser/EditUser';
21 import PaymentPage from './components/PaymentPage/PaymentPage';
22 import QrReaderComponent from './components/QrReaderComponent/QrReaderComponent';
23 import PatientRecords from './components/PatientRecords/PatientRecords';
24 import CreateClinic from './components/CreateClinic/CreateClinic';
25 import ClinicList from './components/ClinicList/ClinicList';
26 import EditClinic from './components/EditClinic/EditClinic';
27 import 'bootstrap-icons/font/bootstrap-icons.css';
28 import './App.css';
29 
30 function App() {
31     return (
32         <Router>
33             <div className="App">
34                 <Header />
35                 <main className="content">
36                     <Routes>
37                         <Route path="/register" element={<Register/>}/>
38                         <Route path="/login" element={<Login/>}/>
39                         <Route path="/home" element={<Home/>}/>
40                         <Route path="/create-schedule" element={<ProtectedRoute role="admin"><CreateSchedule/></ProtectedRoute>}/>
41                         <Route path="/view-schedules" element={<ProtectedRoute roles={['admin', 'doctor']}><ScheduleList /></ProtectedRoute>} />
42                         <Route path="/edit-schedule/:id" element={<ProtectedRoute role="admin"><EditSchedule /></ProtectedRoute>} />
43                         <Route path="/create-medical-record" element={<ProtectedRoute role="doctor"><CreateMedicalRecord /></ProtectedRoute>} />
44                         <Route path="/edit-medical-record/:id" element={<ProtectedRoute role="doctor"><EditMedicalRecord /></ProtectedRoute>} />
45                         <Route path="/medical-records" element={<ProtectedRoute><MedicalRecordList /></ProtectedRoute>} />
46                         <Route path="/create-appointment" element={<ProtectedRoute role="patient"><CreateAppointment/></ProtectedRoute>}/>
47                         <Route path="/appointment-history" element={<ProtectedRoute role="patient"><AppointmentHistory/></ProtectedRoute>}/>
48                         <Route path="/pay/:appointmentId" element={<ProtectedRoute role="patient"><PaymentPage /></ProtectedRoute>} />
49                         <Route path="/doctor-appointments" element={<ProtectedRoute role="doctor"><DoctorAppointments /></ProtectedRoute>} />
50                         <Route path="/user-list" element={<ProtectedRoute role="admin"><UserList /></ProtectedRoute>} />
51                         <Route path="/edit-user/:id" element={<ProtectedRoute><EditUser /></ProtectedRoute>} />
52                         <Route path="/create-clinic" element={<ProtectedRoute role="admin"><CreateClinic /></ProtectedRoute>} />
53                         <Route path="/clinics" element={<ProtectedRoute role="admin"><ClinicList /></ProtectedRoute>}/>
54                         <Route path="/clinics/edit/:id" element={<ProtectedRoute role="admin"><EditClinic /></ProtectedRoute>} />
55                         <Route path="/scan-qr" element={<QrReaderComponent />} />
56                         <Route path="/patient-record/:patient_id" element={<PatientRecords />} />
57                         <Route path="/profile" element={<ProtectedRoute><Profile /></ProtectedRoute>} />
58                     </Routes>
59                 </main>
60                 <Footer/>
61             </div>
62         </Router>
63     );
64 }
65 
66 export default App;


В.2 Код шапки сайту для різних ролей


1 import React from 'react';
2 import { Link, useNavigate } from 'react-router-dom';
3 import { jwtDecode } from 'jwt-decode';
4 import './Header.css';
5 
6 const Header = () => {
7     const navigate = useNavigate();
8     const token = localStorage.getItem('token');
9     let role = '';
10     let userId = '';
11 
12     if (token) {
13         try {
14             const decodedToken = jwtDecode(token);
15             role = decodedToken.role;
16             userId = decodedToken.userId;
17         } catch (error) {
18             console.error('Failed to decode token:', error);
19             localStorage.removeItem('token');
20             navigate('/login');
21         }
22     }
23 
24     const handleLogout = () => {
25         localStorage.removeItem('token');
26         navigate('/login');
27     };
28 
29     return (
30         <header className="header">
31             <div className="logo">Health Connect</div>
32             <nav>
33                 <ul>
34                     <li><Link to="/home">Home</Link></li>
35                     {!token ? (
36                         <>
37                             <li><Link to="/register">Register</Link></li>
38                             <li><Link to="/login">Login</Link></li>
39                         </>
40                     ) : (
41                         <>
42                             {role === 'admin' && (
43                                 <>
44                                     <li><Link to="/create-schedule">Create Schedule</Link></li>
45                                     <li><Link to="/view-schedules">View Schedules</Link></li>
46                                     <li><Link to="/user-list">Manage Users</Link></li>
47                                     <li><Link to="/create-clinic">Create Clinic</Link></li>
48                                     <li><Link to="/clinics">Clinic List</Link></li>
49                                     <li><Link to="/medical-records">Medical Records</Link></li>
50                                 </>
51                             )}
52                             {role === 'doctor' && (
53                                 <>
54                                     <li><Link to="/view-schedules">View Schedules</Link></li>
55                                     <li><Link to="/doctor-appointments">My Appointments</Link></li>
56                                     <li><Link to="/medical-records">Medical Records</Link></li>
57                                 </>
58                             )}
59                             {role === 'patient' && (
60                                 <>
61                                     <li><Link to="/create-appointment">Book Appointment</Link></li>
62                                     <li><Link to="/appointment-history">Appointment History</Link></li>
63                                     <li><Link to={`/patient-record/${userId}`}>Medical Records</Link></li>
64                                 </>
65                             )}
66 
67                             <li><Link to="/profile"><i className="bi bi-person-circle"></i></Link></li>
68                             <li>
69                                 <button onClick={handleLogout}>Logout</button>
70                             </li>
71                         </>
72                     )}
73                 </ul>
74             </nav>
75         </header>
76     );
77 };
78 
79 
80 export default Header;


В.4 Код сторінки створення запису на прийом CreateAppointment.js


1 import React, { useState, useEffect } from 'react';
2 import axios from 'axios';
3 import { useNavigate } from 'react-router-dom';
4 import { jwtDecode } from 'jwt-decode';
5 import './CreateAppointment.css';
6 
7 const CreateAppointment = () => {
8     const [cities, setCities] = useState([]);
9     const [clinics, setClinics] = useState([]);
10     const [doctors, setDoctors] = useState([]);
11     const [schedules, setSchedules] = useState([]);
12     const [availableDates, setAvailableDates] = useState([]);
13     const [availableTimes, setAvailableTimes] = useState([]);
14     const [appointmentData, setAppointmentData] = useState({
15         city: '',
16         clinic_id: '',
17         doctor_id: '',
18         appointment_date: '',
19         appointment_time: '',
20         services: []
21     });
22     const [error, setError] = useState(null);
23     const token = localStorage.getItem('token');
24     const navigate = useNavigate();
25 
26     useEffect(() => {
27         const fetchCities = async () => {
28             try {
29                 const response = await axios.get('http://localhost:3000/api/clinics/all');
30                 const clinicsData = response.data;
31                 const citiesData = [...new Set(clinicsData.map(clinic => clinic.city))];
32                 setCities(citiesData);
33                 setClinics(clinicsData);
34             } catch (error) {
35                 console.error('Failed to fetch cities and clinics:', error);
36             }
37         };
38 
39         fetchCities();
40     }, []);
41 
42     const handleCityChange = (e) => {
43         const { name, value } = e.target;
44         setAppointmentData({
45             ...appointmentData,
46             [name]: value,
47             clinic_id: '',
48             doctor_id: ''
49         });
50 
51         const filteredClinics = clinics.filter(clinic => clinic.city === value);
52         setClinics(filteredClinics);
53         setDoctors([]);
54         setSchedules([]);
55         setAvailableDates([]);
56         setAvailableTimes([]);
57     };
58 
59     const handleClinicChange = async (e) => {
60         const { name, value } = e.target;
61         const clinicId = value;
62 
63         setAppointmentData(prevData => ({
64             ...prevData,
65             [name]: value,
66             clinic_id: clinicId,
67             doctor_id: ''
68         }));
69 
70         try {
71             const response = await axios.get(`http://localhost:3000/api/users/doctors?clinic_id=${clinicId}`, {
72                 headers: { Authorization: `Bearer ${token}` },
73             });
74             setDoctors(response.data);
75             setSchedules([]);
76             setAvailableDates([]);
77             setAvailableTimes([]);
78         } catch (error) {
79             console.error('Failed to fetch doctors:', error);
80         }
81     };
82 
83 
84 
85     const handleDoctorChange = async (e) => {
86         const { name, value } = e.target;
87         setAppointmentData(prevData => ({
88             ...prevData,
89             [name]: value,
90         }));
91 
92         try {
93             const response = await axios.get('http://localhost:3000/api/schedules/all', {
94                 headers: { Authorization: `Bearer ${token}` },
95             });
96             const doctorSchedules = response.data.filter((schedule) => schedule.doctor_id._id === value);
97             setSchedules(doctorSchedules);
98             const uniqueDates = [...new Set(doctorSchedules.map(schedule => schedule.date))];
99             setAvailableDates(uniqueDates);
100             setAvailableTimes([]);
101         } catch (error) {
102             console.error('Failed to fetch schedules:', error);
103         }
104     };
105 
106 
107     const handleDateChange = (e) => {
108         const { name, value } = e.target;
109         setAppointmentData({
110             ...appointmentData,
111             [name]: value,
112         });
113 
114         const selectedDateSchedule = schedules.filter(schedule => schedule.date === value);
115         const times = [];
116         selectedDateSchedule.forEach(schedule => {
117             let currentTime = parseTime(schedule.start_time);
118             const endTime = parseTime(schedule.end_time);
119             while (currentTime < endTime) {
120                 times.push(formatTime(currentTime));
121                 currentTime += 30 * 60 * 1000;
122             }
123         });
124         setAvailableTimes(times);
125     };
126 
127     const parseTime = (timeString) => {
128         const [hours, minutes] = timeString.split(':');
129         return new Date(0, 0, 0, hours, minutes).getTime();
130     };
131 
132     const formatTime = (time) => {
133         const date = new Date(time);
134         const hours = date.getHours();
135         const minutes = date.getMinutes();
136         return `${hours}:${minutes < 10 ? '0' : ''}${minutes}`;
137     };
138 
139 
140     const handleServiceChange = (e) => {
141         const { value, checked } = e.target;
142         if (checked) {
143             setAppointmentData({
144                 ...appointmentData,
145                 services: [...appointmentData.services, value]
146             });
147         } else {
148             setAppointmentData({
149                 ...appointmentData,
150                 services: appointmentData.services.filter(service => service !== value)
151             });
152         }
153     };
154 
155     const handleChange = (e) => {
156         const { name, value } = e.target;
157         setAppointmentData({
158             ...appointmentData,
159             [name]: value,
160         });
161     };
162 
163     const handleSubmit = async (e) => {
164         e.preventDefault();
165         const { doctor_id, appointment_date, appointment_time, services, clinic_id } = appointmentData;
166         const patient_id = jwtDecode(token).userId;
167 
168         try {
169             await axios.post(
170                 'http://localhost:3000/api/appointments/create',
171                 { patient_id, doctor_id, appointment_date, appointment_time, services, clinic_id },
172                 {
173                     headers: { Authorization: `Bearer ${token}` },
174                 }
175             );
176             navigate('/appointment-history');
177         } catch (error) {
178             setError('Failed to create appointment');
179         }
180     };
181 
182 
183     return (
184         <div className="create-appointment-form">
185             <h2>Create Appointment</h2>
186             <form onSubmit={handleSubmit}>
187                 <div className="form-group">
188                     <label>City</label>
189                     <select name="city" value={appointmentData.city} onChange={handleCityChange} required>
190                         <option value="">Select a city</option>
191                         {cities.map((city, index) => (
192                             <option key={index} value={city}>
193                                 {city}
194                             </option>
195                         ))}
196                     </select>
197                 </div>
198                 {appointmentData.city && (
199                     <div className="form-group">
200                         <label>Clinic</label>
201                         <select name="clinic_id" value={appointmentData.clinic_id} onChange={handleClinicChange}
202                                 required>
203                             <option value="">Select a clinic</option>
204                             {clinics.map(clinic => (
205                                 <option key={clinic._id} value={clinic._id}>
206                                     {clinic.name} - {clinic.address}
207                                 </option>
208                             ))}
209                         </select>
210                     </div>
211                 )}
212                 {appointmentData.clinic_id && (
213                     <div className="form-group">
214                         <label>Doctor</label>
215                         <select name="doctor_id" value={appointmentData.doctor_id} onChange={handleDoctorChange}
216                                 required>
217                             <option value="">Select a doctor</option>
218                             {doctors.map(doctor => (
219                                 <option key={doctor._id} value={doctor._id}>
220                                     {doctor.first_name} {doctor.last_name}
221                                 </option>
222                             ))}
223                         </select>
224                     </div>
225                 )}
226                 {availableDates.length > 0 && (
227                     <div className="form-group">
228                         <label>Date</label>
229                         <select name="appointment_date" value={appointmentData.appointment_date}
230                                 onChange={handleDateChange} required>
231                             <option value="">Select a date</option>
232                             {availableDates.map((date, index) => (
233                                 <option key={index} value={date}>
234                                     {date}
235                                 </option>
236                             ))}
237                         </select>
238                     </div>
239                 )}
240                 {availableTimes.length > 0 && (
241                     <div className="form-group">
242                         <label>Time</label>
243                         <select name="appointment_time" value={appointmentData.appointment_time} onChange={handleChange}
244                                 required>
245                             <option value="">Select a time</option>
246                             {availableTimes.map((time, index) => (
247                                 <option key={index} value={time}>
248                                     {time}
249                                 </option>
250                             ))}
251                         </select>
252                     </div>
253                 )}
254                 <div className="form-group">
255                     <label>Services</label>
256                     < 256 div className="checkbox-group">
257                         <label>
258                             <input
259                                 type="checkbox"
260                                 value="Consultation"
261                                 checked={appointmentData.services.includes('Consultation')}
262                                 onChange={handleServiceChange}
263                             />
264                             <span className="checkbox-label">Consultation (200 UAH)</span>
265                         </label>
266                         <label>
267                             <input
268                                 type="checkbox"
269                                 value="Ultrasound"
270                                 checked={appointmentData.services.includes('Ultrasound')}
271                                 onChange={handleServiceChange}
272                             />
273                             <span className="checkbox-label">Ultrasound (300 UAH)</span>
274                         </label>
275                         <label>
276                             <input
277                                 type="checkbox"
278                                 value="Blood Test"
279                                 checked={appointmentData.services.includes('Blood Test')}
280                                 onChange={handleServiceChange}
281                             />
282                             <span className="checkbox-label">Blood Test (150 UAH)</span>
283                         </label>
284                         <label>
285                             <input
286                                 type="checkbox"
287                                 value="X-Ray"
288                                 checked={appointmentData.services.includes('X-Ray')}
289                                 onChange={handleServiceChange}
290                             />
291                             <span className="checkbox-label">X-Ray (200 UAH)</span>
292                         </label>
293                     </div>
294                 </div>
295                 <button type="submit">Create Appointment</button>
296             </form>
297             {error && <p className="error-message">{error}</p>}
298         </div>
299     );
300 };
301 
302 export default CreateAppointment;



